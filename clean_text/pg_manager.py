from fileinput import filename
import psycopg2
import os
from configparser import ConfigParser

def config(filename='config.ini', section='postgresql'):
    parser = ConfigParser()
    parser.read(filename)
    db = {}
    if parser.has_section(section):
        params = parser.items(section)
        for param in params:
            db[param[0]] = param[1]
    else:
        raise Exception('Section {0} not found in the {1} file'.format(section, filename))

    return db

def pg_select(table, where_cond=''):
    try:
        params = config()        
        connection = psycopg2.connect(**params)

        cursor = connection.cursor()
        postgreSQL_select_Query = f'select * from {table}'
        if(where_cond != ''):
            postgreSQL_select_Query += f' where {where_cond}'
        cursor.execute(postgreSQL_select_Query)
        response_records = cursor.fetchall()
        return response_records

    except (Exception, psycopg2.Error) as error:
        print("Error while fetching data from PostgreSQL", error)

    finally:
        # closing database connection.
        if connection:
            cursor.close()
            connection.close()

def pg_run_query(query, with_response=False):
    conn = None
    response = None
    try:
        params = config()
        conn = psycopg2.connect(**params)
        cur = conn.cursor()
        cur.execute(query)
        if(with_response):
            response = cur.fetchall()
        conn.commit()
        cur.close()
        if(with_response):
            return response

    except (Exception, psycopg2.DatabaseError) as error:
        print(error)
    finally:
        if conn is not None:
            conn.close()

    return response

def pg_upsert(table, query_params, values, conflict = ''):
    conn = None
    sql = f"INSERT INTO {table}({','.join(query_params)}) VALUES({','.join(values)})"
    if(conflict != ''):
        sql += f" ON CONFLICT ({conflict}) DO UPDATE SET"
        for param in query_params:
            if(param != conflict):
                sql += f" {param} = EXCLUDED.{param} "
    try:
        params = config()
        conn = psycopg2.connect(**params)
        cur = conn.cursor()
        cur.execute(sql)
        conn.commit()
        cur.close()

    except (Exception, psycopg2.DatabaseError) as error:
        print(error)
    finally:
        if conn is not None:
            conn.close()
        
def create_freq_table(file_name):
    print(f'Creating table public.{file_name}_freq!')

    query = f'''CREATE TABLE IF NOT EXISTS public.{file_name}_freq (
	id int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
	word varchar NOT NULL,
	freq int8 NULL DEFAULT 0,
	CONSTRAINT {file_name}_freq_pk PRIMARY KEY (id),
	CONSTRAINT {file_name}_freq_un UNIQUE (word)
    );
    CREATE INDEX IF NOT EXISTS {file_name}_freq_word_idx ON public.{file_name}_freq USING btree (word)'''
    pg_run_query(query)

def create_text_table(file_name):
    print(f'Creating table public.{file_name}_text!')

    query = f'''CREATE TABLE IF NOT EXISTS public.{file_name}_text (
	id int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
	word varchar NOT NULL,
	word_line int8 NOT NULL,
	word_position int8 NOT NULL,
	CONSTRAINT {file_name}_pk PRIMARY KEY (id),
	CONSTRAINT {file_name}_un UNIQUE (word_line, word_position))'''
    pg_run_query(query)

def check_text_cleaner_tables_exists(in_file):
    file_name = os.path.basename(in_file)
    file_name = file_name.split('.')[0]

    query = f'''SELECT 
    COUNT(table_name)
    FROM 
        information_schema.tables 
    WHERE 
    table_schema ILIKE 'public' AND 
    table_type ILIKE 'BASE TABLE' AND
	(table_name  ILIKE '{file_name}_freq' or table_name  ILIKE '{file_name}_text');'''
    response = pg_run_query(query, True)
    return response[0][0] == 2

def pg_upsert_from_dictionary(table, query_params, dict, conflict = ''):
    conn = None

    try:
        params = config()
        conn = psycopg2.connect(**params)
        cur = conn.cursor()
        i = 1
        print(f'size: {len(dict.keys())}')
        for key in dict.keys():            
            sql = f"INSERT INTO {table}({','.join(query_params)}) VALUES('{key}','{dict[key]}')"
            if(conflict != ''):
                sql += f" ON CONFLICT ({conflict}) DO UPDATE SET"
                for param in query_params:
                    if(param != conflict):
                        sql += f" {param} = EXCLUDED.{param} "
            cur.execute(sql)
            i += 1
            if(i % 10000 == 0):
                    print(f'{round(i/len(dict.keys())*100, 2)}%')
        conn.commit()
        cur.close()

    except (Exception, psycopg2.DatabaseError) as error:
        print(error)
    finally:
        if conn is not None:
            conn.close()

def pg_upsert_from_text(in_file):
    conn = None

    file_name = os.path.basename(in_file)
    file_name = file_name.split('.')[0]
    create_text_table(file_name)
    
    try:
        params = config()
        conn = psycopg2.connect(**params)
        cur = conn.cursor()

        with open(in_file, 'r', encoding="utf8") as in_file:
            text = in_file.readlines()
            print(f'size: {len(text)}')
            i = 1
            for line in text:
                line = line.replace('\n','')
                line = line.replace("'","''")
                sql = f"insert into {file_name}_text(word, word_line, word_position) select a, {i}, ROW_NUMBER () OVER ( ORDER BY (select null) ) rank_number from unnest(string_to_array('{line}', ' ')) a ;"
                cur.execute(sql)
                i += 1
                if(i % 10000 == 0):
                    print(f'{round(i/len(text)*100, 2)}%')
        conn.commit()
        cur.close()

    except (Exception, psycopg2.DatabaseError) as error:
        print(error)
    finally:
        if conn is not None:
            conn.close()